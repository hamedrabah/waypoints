// Global variables
let map;
let markers = []; // Change from single marker to array of markers
let waypoints = []; // Store multiple waypoints
let geocodedLat;
let geocodedLng;
let selectedImage = null;
let panorama; // Street View panorama
let infoWindows = []; // Keep track of info windows
let callsData = []; // Store 911 calls data
let callMarkers = []; // Store markers for 911 calls
const sampleImageResultsCache = {};
let droneMarker = null; // Drone marker for simulation
let simulationInProgress = false; // Flag to track if simulation is active
let simulationPaused = false; // Flag to track if simulation is paused
let simulationAnimationId = null; // To store the animation frame ID
let currentLeg = 0; // Current leg of the journey
let legProgress = 0; // Progress along the current leg (0-1)
let simulationSpeed = 50; // Speed in meters per second

// Add a DOM ready function to ensure elements exist before accessing them
function initEventListeners() {
  // Navigation between address and image sections
  const addressNav = document.getElementById('address-nav');
  const imageNav = document.getElementById('image-nav');
  const addressSection = document.getElementById('address-section');
  const imageSection = document.getElementById('image-section');

  if (addressNav && imageNav && addressSection && imageSection) {
    addressNav.addEventListener('click', () => {
      addressNav.classList.add('active');
      imageNav.classList.remove('active');
      addressSection.classList.add('active');
      imageSection.classList.remove('active');
    });

    imageNav.addEventListener('click', () => {
      imageNav.classList.add('active');
      addressNav.classList.remove('active');
      imageSection.classList.add('active');
      addressSection.classList.remove('active');
    });
  }

  // Set up the file uploader
  const uploaderContainer = document.getElementById('uploaderContainer');
  const imageUpload = document.getElementById('imageUpload');
  
  if (uploaderContainer && imageUpload) {
    // Click on the container to trigger file input
    uploaderContainer.addEventListener('click', function() {
      imageUpload.click();
    });
    
    // Handle file selection change
    imageUpload.addEventListener('change', function(event) {
      handleImageSelection(event);
    });
    
    // Handle drag and drop
    uploaderContainer.addEventListener('dragover', function(e) {
      e.preventDefault();
      uploaderContainer.classList.add('uploader-container-active');
    });
    
    uploaderContainer.addEventListener('dragleave', function() {
      uploaderContainer.classList.remove('uploader-container-active');
    });
    
    uploaderContainer.addEventListener('drop', function(e) {
      e.preventDefault();
      uploaderContainer.classList.remove('uploader-container-active');
      
      if (e.dataTransfer.files.length) {
        imageUpload.files = e.dataTransfer.files;
        handleImageSelection({ target: imageUpload });
      }
    });
  }
  
  // Set up sample image selection
  const sampleImages = document.querySelectorAll('.sample-image');
  sampleImages.forEach(img => {
    img.addEventListener('click', function() {
      // Remove selected class from all sample images
      sampleImages.forEach(sample => sample.classList.remove('selected'));
      // Add selected class to this image
      this.classList.add('selected');
      
      // Get the sample name from data attribute
      const sampleName = this.getAttribute('data-sample');
      
      // Handle the sample image selection
      handleSampleImageSelection(sampleName);
    });
  });
  
  // Set up image removal button
  const removeImageBtn = document.getElementById('removeImage');
  if (removeImageBtn) {
    removeImageBtn.addEventListener('click', function() {
      resetImageUpload();
    });
  }
  
  // Set up Close Street View button
  const closeStreetViewBtn = document.getElementById('closeStreetView');
  if (closeStreetViewBtn) {
    closeStreetViewBtn.addEventListener('click', function() {
      document.getElementById('street-view-container').style.display = 'none';
    });
  }
  
  // Setup header buttons
  setupHeaderButtons();
  
  // Setup notebook icon click
  const notebookLink = document.querySelector('.sidebar-nav .nav-link[title="Notebook"]');
  if (notebookLink) {
    notebookLink.addEventListener('click', function(e) {
      e.preventDefault();
      
      // Update active state
      document.querySelectorAll('.sidebar-nav .nav-link').forEach(link => {
        link.classList.remove('active');
      });
      this.classList.add('active');
      
      // Hide all main app content
      document.getElementById('resultSection').style.display = 'none';
      document.querySelector('.card.mb-4').style.display = 'none'; // Hide the tabbed input card
      document.querySelector('.dashboard-layout').style.display = 'none'; // Hide the dashboard layout
      
      // Create or show notebook section
      let helloWorldSection = document.getElementById('helloWorldSection');
      if (!helloWorldSection) {
        helloWorldSection = document.createElement('div');
        helloWorldSection.id = 'helloWorldSection';
        helloWorldSection.className = 'card';
        helloWorldSection.innerHTML = `
          <div class="card-header">Project Documentation</div>
          <div class="card-body markdown-content">
            <h1>Situational Awareness & Waypoint Tool for Urban DFR Ops</h1>

            <p><strong>Repository:</strong> <a href="https://github.com/hamedrabah/waypoints" target="_blank">hamedrabah/waypoints</a><br>
            <strong>Stack:</strong> JavaScript, Leaflet.js, Socrata API, Reverse Image Geocoding (custom pipeline), OpenStreetMap</p>

            <hr>

            <h2>Overview</h2>

            <p>This is a working prototype of a map-first interface that enables fast drone waypoint insertion, real-time incident monitoring, and image-based location identification‚Äîpurpose-built for Drone as First Responder (DFR) workflows. The project simulates how an RTCC or dispatch operator could rapidly deploy Skydio drones in an urban environment with minimal input friction and maximum operational clarity.</p>

            <p>The demo is scoped to San Francisco by design‚Äîbalancing real-world data integration with the constraints of a focused, high-fidelity test environment.</p>

            <hr>

            <h2>Core Features</h2>

            <h3>üîç Reverse Image Lookup</h3>

            <p>Upload an image of a scene (e.g., user-submitted footage, camera still, social media post), and the app attempts to geolocate it by matching visual elements to known street data. The system outputs a <strong>ranked list of confidence-weighted geocoded matches</strong>, helping operators rapidly orient to the likely location.</p>

            <blockquote>
              <p><strong>Use case:</strong> A dispatcher receives a photo from a civilian tipline or internal BWC footage‚Äîbefore the officer finishes describing the location, the system suggests GPS coordinates.</p>
            </blockquote>

            <hr>

            <h3>üì° Real-Time Calls for Service Integration (Socrata API)</h3>

            <p>Live feed of 911 calls is ingested directly from <strong>San Francisco's Socrata portal</strong>, part of Tyler Technologies' open data platform. The interface parses metadata (type, timestamp, address, priority) and maps each event. Filters enable operators to hone in on high-priority calls or specific incident types (e.g., assaults, traffic collisions).</p>

            <blockquote>
              <p><strong>Use case:</strong> Operator scans active incidents and clicks one to auto-generate a drone waypoint, skipping manual address input.</p>
            </blockquote>

            <hr>

            <h3>üó∫Ô∏è Map-Centered Interface with Flexible Inputs</h3>

            <p>Users can:</p>
            <ul>
              <li>Type an address manually</li>
              <li>Upload an image for reverse geolocation</li>
              <li>Click on a location directly on the map</li>
            </ul>

            <p>Each action results in a recommended waypoint marker. The UI is optimized for both mouse-and-keyboard setups (dispatch center) and touch interfaces (e.g., tablets in patrol vehicles).</p>

            <hr>

            <h2>Purposeful Constraints</h2>

            <ul>
              <li><strong>San Francisco Geofence:</strong> This isn't a limitation‚Äîit's a realism choice. It allows high-quality testing and reflects how actual DFR deployments start within tightly defined municipal boundaries.</li>
              <li><strong>Operator-Centered UX:</strong> The interface prioritizes clarity, speed, and click-reduction. It's designed to fit into an operator's flow rather than compete for attention with unnecessary elements.</li>
            </ul>

            <hr>

            <h2>Technical Integration Readiness</h2>

            <ul>
              <li>Waypoint logic is built around compatibility with Skydio's developer API (authentication and mission commands abstracted and modular).</li>
              <li>Strong separation between data ingestion (e.g., Socrata, reverse geocoding) and map rendering logic, allowing this system to be extended to other cities or integrated with additional drone platforms.</li>
              <li>Future features in roadmap:
                <ul>
                  <li>Drone telemetry overlays</li>
                  <li>Live stream embedding from drone feeds</li>
                  <li>Session logging for audit and FOIA compliance</li>
                </ul>
              </li>
            </ul>

            <hr>

            <h2>Why It Matters</h2>

            <p>This tool isn't just a demo‚Äîit reflects real pain points from actual public safety workflows. It was designed with the field realities of RTCCs, drone operators, and dispatchers in mind.</p>

            <p>The goal:<br>
            <strong>Three fewer clicks. Ten more seconds of clarity. One less tool to juggle.</strong></p>
          </div>
        `;
        document.querySelector('.content-wrapper').appendChild(helloWorldSection);
      } else {
        helloWorldSection.style.display = 'block';
      }
    });
  }
  
  // Setup map icon click to return to the main interface
  const mapLink = document.querySelector('.sidebar-nav .nav-link[title="Map"]');
  if (mapLink) {
    mapLink.addEventListener('click', function(e) {
      e.preventDefault();
      
      // Update active state
      document.querySelectorAll('.sidebar-nav .nav-link').forEach(link => {
        link.classList.remove('active');
      });
      this.classList.add('active');
      
      // Show all main app content
      const resultSection = document.getElementById('resultSection');
      const inputCard = document.querySelector('.card.mb-4');
      const dashboardLayout = document.querySelector('.dashboard-layout');
      
      if (resultSection) resultSection.style.display = 'flex';
      if (inputCard) inputCard.style.display = 'block';
      if (dashboardLayout) dashboardLayout.style.display = 'grid';
      
      // Hide the notebook
      const helloWorldSection = document.getElementById('helloWorldSection');
      if (helloWorldSection) {
        helloWorldSection.style.display = 'none';
      }
      
      // Center the map if it exists
      if (window.map) {
        window.map.setCenter({ lat: 37.7749, lng: -122.4194 });
        window.map.setZoom(13);
        
        // Force a resize event on the map to ensure it renders properly
        setTimeout(() => {
          window.dispatchEvent(new Event('resize'));
        }, 100);
      } else {
        console.log('Map not initialized yet');
      }
    });
  }
  
  // Setup calls search button
  const callsSearchBtn = document.getElementById('callsSearchBtn');
  if (callsSearchBtn) {
    callsSearchBtn.addEventListener('click', searchCalls);
  }
  
  // Setup calls search input (search on Enter key)
  const callsSearch = document.getElementById('callsSearch');
  if (callsSearch) {
    callsSearch.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        searchCalls();
      }
    });
  }
  
  // Setup calls limit dropdown
  const callsLimit = document.getElementById('callsLimit');
  if (callsLimit) {
    callsLimit.addEventListener('change', function() {
      fetchRecentCalls(this.value);
    });
  }
  
  // Setup calls severity filter
  const callsSeverity = document.getElementById('callsSeverity');
  if (callsSeverity) {
    callsSeverity.addEventListener('change', function() {
      filterCallsBySeverity(this.value);
    });
  }
  
  // Setup export waypoints button
  const exportWaypointsBtn = document.getElementById('exportWaypointsBtn');
  if (exportWaypointsBtn) {
    exportWaypointsBtn.addEventListener('click', exportWaypoints);
  }
  
  // Setup address form submission
  const addressForm = document.getElementById('addressForm');
  if (addressForm) {
    addressForm.addEventListener('submit', addressFormSubmit);
  }
  
  // Setup image form submission
  const imageForm = document.getElementById('imageForm');
  if (imageForm) {
    imageForm.addEventListener('submit', imageFormSubmit);
  }
  
  // Load 911 calls automatically when page loads
  fetchRecentCalls();
}

// Initialize the map (callback for Google Maps API)
function initMap() {
  // Default center (can be anywhere, will update when an address is entered)
  const defaultCenter = { lat: 37.7749, lng: -122.4194 }; // San Francisco
  
  // Check if map element exists
  let mapElement = document.getElementById('map');
  
  // If map element doesn't exist or isn't visible, try to show the result section
  if (!mapElement || mapElement.offsetParent === null) {
    // Try to get the map element again after showing the section
    mapElement = document.getElementById('map');
    
    // If map still doesn't exist, log an error and return
    if (!mapElement) {
      console.error('Map element not found');
      return;
    }
  }
  
  // Dark mode map style to match Skydio UI
  const darkMapStyle = [
    { elementType: "geometry", stylers: [{ color: "#242f3e" }] },
    { elementType: "labels.text.stroke", stylers: [{ color: "#242f3e" }] },
    { elementType: "labels.text.fill", stylers: [{ color: "#746855" }] },
    {
      featureType: "administrative.locality",
      elementType: "labels.text.fill",
      stylers: [{ color: "#d59563" }],
    },
    {
      featureType: "poi",
      elementType: "labels.text.fill",
      stylers: [{ color: "#d59563" }],
    },
    {
      featureType: "poi.park",
      elementType: "geometry",
      stylers: [{ color: "#263c3f" }],
    },
    {
      featureType: "poi.park",
      elementType: "labels.text.fill",
      stylers: [{ color: "#6b9a76" }],
    },
    {
      featureType: "road",
      elementType: "geometry",
      stylers: [{ color: "#38414e" }],
    },
    {
      featureType: "road",
      elementType: "geometry.stroke",
      stylers: [{ color: "#212a37" }],
    },
    {
      featureType: "road",
      elementType: "labels.text.fill",
      stylers: [{ color: "#9ca5b3" }],
    },
    {
      featureType: "road.highway",
      elementType: "geometry",
      stylers: [{ color: "#746855" }],
    },
    {
      featureType: "road.highway",
      elementType: "geometry.stroke",
      stylers: [{ color: "#1f2835" }],
    },
    {
      featureType: "road.highway",
      elementType: "labels.text.fill",
      stylers: [{ color: "#f3d19c" }],
    },
    {
      featureType: "transit",
      elementType: "geometry",
      stylers: [{ color: "#2f3948" }],
    },
    {
      featureType: "transit.station",
      elementType: "labels.text.fill",
      stylers: [{ color: "#d59563" }],
    },
    {
      featureType: "water",
      elementType: "geometry",
      stylers: [{ color: "#17263c" }],
    },
    {
      featureType: "water",
      elementType: "labels.text.fill",
      stylers: [{ color: "#515c6d" }],
    },
    {
      featureType: "water",
      elementType: "labels.text.stroke",
      stylers: [{ color: "#17263c" }],
    },
  ];
  
  map = new google.maps.Map(mapElement, {
    zoom: 13,
    center: defaultCenter,
    mapTypeControl: true,
    streetViewControl: true,
    fullscreenControl: true,
    mapTypeControlOptions: {
      style: google.maps.MapTypeControlStyle.DROPDOWN_MENU
    },
    styles: darkMapStyle
  });
  
  // Add a button to clear all waypoints
  const clearButton = document.createElement('button');
  clearButton.textContent = 'Clear All Waypoints';
  clearButton.className = 'custom-map-button';
  clearButton.addEventListener('click', clearAllWaypoints);
  
  // Add export button for waypoints
  const exportButton = document.createElement('button');
  exportButton.textContent = 'Export Waypoints';
  exportButton.className = 'custom-map-button';
  exportButton.addEventListener('click', exportWaypoints);
  
  map.controls[google.maps.ControlPosition.TOP_RIGHT].push(clearButton);
  map.controls[google.maps.ControlPosition.TOP_RIGHT].push(exportButton);

  // Add Google Places Autocomplete to the address input
  const addressInput = document.getElementById('address');
  if (addressInput && google.maps.places) {
    // Apply dark theme styling to the address input
    addressInput.style.backgroundColor = '#242f3e';
    addressInput.style.color = '#ffffff';
    addressInput.style.border = '1px solid #38414e';
    // Add focus styles via a class to avoid inline style limitations
    if (!document.getElementById('dark-input-styles')) {
      const style = document.createElement('style');
      style.id = 'dark-input-styles';
      style.textContent = `
        #address {
          background-color: #242f3e;
          color: #ffffff;
          border: 1px solid #38414e;
          border-radius: 4px;
          padding: 8px 12px;
          transition: all 0.3s ease;
        }
        #address::placeholder {
          color: #9ca5b3;
        }
        #address:focus {
          border-color: #00a0f5;
          box-shadow: 0 0 0 2px rgba(0, 160, 245, 0.2);
          outline: none;
        }
        .pac-container {
          background-color: #242f3e;
          border: 1px solid #38414e;
          border-radius: 0 0 4px 4px;
          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        .pac-item {
          border-top: 1px solid #38414e;
          color: #5d6d7e;
          padding: 8px;
        }
        .pac-item:hover {
          background-color: #1a2434;
        }
        .pac-item-selected {
          background-color: #1a2434;
        }
        .pac-matched, .pac-item-query, .pac-item * {
          color: #5d6d7e !important;
        }
        .pac-icon {
          filter: invert(100%);
        }
      `;
      document.head.appendChild(style);
    }

    // Define bounds for San Francisco
    const sfBounds = new google.maps.LatLngBounds(
      new google.maps.LatLng(37.703399, -123.017731), // Southwest corner
      new google.maps.LatLng(37.812072, -122.3482)    // Northeast corner
    );
    const autocomplete = new google.maps.places.Autocomplete(addressInput, {
      fields: ['formatted_address', 'geometry', 'name', 'place_id'],
      bounds: sfBounds,
      strictBounds: true,
      componentRestrictions: { country: 'us' }
    });
    autocomplete.addListener('place_changed', function() {
      const place = autocomplete.getPlace();
      if (place && (place.formatted_address || place.name)) {
        // Prefer formatted_address, fallback to name
        addressInput.value = place.formatted_address || place.name;
      }
    });
  }

  // Make sure the result section (with map) is visible
  document.getElementById('resultSection').style.display = 'flex';

  // Initialize event listeners
  initEventListeners();
}

// Make initMap globally accessible for the Google Maps API callback
window.initMap = initMap;

// Setup interactive elements in the header
function setupHeaderButtons() {
  const headerButtons = document.querySelectorAll('.header-btn');
  
  headerButtons.forEach(button => {
    button.addEventListener('click', function() {
      // Toggle active state
      headerButtons.forEach(btn => btn.classList.remove('active'));
      this.classList.add('active');
      
      // Handle button actions based on text
      const buttonText = this.textContent.trim();
      
      if (buttonText.includes('Map')) {
        // Make sure the result section is visible first
        const resultSection = document.getElementById('resultSection');
        if (resultSection) {
          resultSection.style.display = 'block';
        }
        
        // Check if map is initialized
        if (window.google && window.google.maps && window.map) {
          // Center map on San Francisco
          window.map.setCenter({ lat: 37.7749, lng: -122.4194 });
          window.map.setZoom(13);
        } else {
          console.error('Google Maps not loaded or map not initialized');
          // Try to initialize map if the element exists
          const mapElement = document.getElementById('map');
          if (mapElement && typeof initMap === 'function') {
            console.log('Attempting to initialize map');
            initMap();
          } else {
            alert('Map view not available. Please check if Google Maps API is loaded.');
          }
        }
      } else if (buttonText.includes('Split')) {
        // Mock split view functionality
        alert('Split view would show map and camera feed side by side');
      } else if (buttonText.includes('Video')) {
        // Mock video view functionality
        alert('Video view would show live drone camera feed');
      }
    });
  });
}

// Handle image selection for upload
function handleImageSelection(event) {
  selectedImage = event.target.files[0];
  
  if (selectedImage) {
    const reader = new FileReader();
    reader.onload = function(e) {
      const previewImg = document.getElementById('previewImg');
      if (previewImg) {
        previewImg.src = e.target.result;
        document.getElementById('imagePreview').style.display = 'block';
        document.getElementById('uploaderContainer').style.display = 'none';
      }
    };
    reader.readAsDataURL(selectedImage);
  } else {
    resetImageUpload();
  }
}

// Reset the image upload
function resetImageUpload() {
  selectedImage = null;
  document.getElementById('imageUpload').value = '';
  document.getElementById('imagePreview').style.display = 'none';
  document.getElementById('uploaderContainer').style.display = 'block';
}

// Handle sample image selection
async function handleSampleImageSelection(sampleName) {
  try {
    // Reset previous selection
    resetImageUpload();
    
    // Map sample names to image files
    const sampleImageFiles = {
      'golden-gate': '1.jpg',
      'painted-ladies': '2.jpg',
      'lombard-street': '3.jpg',
      'fishermans-wharf': '4.jpg',
      'chinatown': '5.jpeg'
    };
    
    const fileName = sampleImageFiles[sampleName];
    if (!fileName) {
      throw new Error('Unknown sample image');
    }
    
    // Display the image preview
    const previewImg = document.getElementById('previewImg');
    document.getElementById('imagePreview').style.display = 'block';
    document.getElementById('uploaderContainer').style.display = 'none';
    
    // Set the image source to the actual image file
    const imagePath = `images/${fileName}`;
    previewImg.src = imagePath;
    
    // Fetch the image as a blob
    const response = await fetch(imagePath);
    const blob = await response.blob();
    
    // Create a File object from the blob
    selectedImage = new File([blob], fileName, { type: blob.type });
    
    // If we have cached results, use them
    if (sampleImageResultsCache[sampleName]) {
      displayImageAnalysisResults(sampleImageResultsCache[sampleName], previewImg.src);
      return;
    }
    
    // Otherwise, send to backend for analysis (same as imageFormSubmit)
    // Show loading state
    const submitButton = document.querySelector('#imageForm button[type="submit"]');
    let originalText = '';
    if (submitButton) {
      originalText = submitButton.innerHTML;
      submitButton.disabled = true;
      submitButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Analyzing image...';
    }
    
    // Create a FormData object and append the image and city
    const formData = new FormData();
    formData.append('image', selectedImage);
    formData.append('city', 'San Francisco');
    
    try {
      const apiResponse = await fetch('/api/analyze-image', {
        method: 'POST',
        body: formData
      });
      if (!apiResponse.ok) {
        const errorData = await apiResponse.json();
        throw new Error(errorData.error || 'Failed to analyze image');
      }
      const data = await apiResponse.json();
      // Cache the result
      sampleImageResultsCache[sampleName] = data;
      // Display the results
      displayImageAnalysisResults(data, previewImg.src);
    } catch (error) {
      showError(error.message || 'An error occurred.');
    } finally {
      if (submitButton) {
        submitButton.disabled = false;
        submitButton.innerHTML = originalText || '<i class="bi bi-search"></i> Analyze Image & Create Waypoint';
      }
    }
  } catch (error) {
    console.error('Error handling sample image selection:', error);
    showError('Failed to load sample image: ' + error.message);
    resetImageUpload();
  }
}

// Helper to display analysis results (used by both imageFormSubmit and sample images)
function displayImageAnalysisResults(data, imageDataUrl) {
  // Save the image data to display in results
  // Clear existing markers
  markers.forEach(marker => marker.setMap(null));
  markers = [];

  // Close any open info windows
  infoWindows.forEach(infoWindow => infoWindow.close());
  infoWindows = [];

  // If the response has multiple locations
  if (data.locations && Array.isArray(data.locations)) {
    // Use the first (highest confidence) location as the primary
    const primaryLocation = data.locations[0];

    // Use the analyzed location to create a waypoint
    createWaypoint(primaryLocation.lat, primaryLocation.lng, primaryLocation.location_description).then(waypointResult => {
      // Update the UI with the results
      document.getElementById('formattedAddress').textContent = primaryLocation.location_description;
      document.getElementById('coordinates').textContent = `${primaryLocation.lat.toFixed(6)}, ${primaryLocation.lng.toFixed(6)}`;
      if (waypointResult.simulation) {
        document.getElementById('waypointStatus').textContent = 'Waypoint added to map. Use Export button to save.';
      } else {
        document.getElementById('waypointStatus').textContent = 'Waypoint created successfully';
      }
      // Add the waypoint to our collection
      const newWaypoint = {
        lat: primaryLocation.lat,
        lng: primaryLocation.lng,
        address: primaryLocation.location_description,
        name: `Waypoint ${waypoints.length + 1}`,
        altitude: 50
      };
      waypoints.push(newWaypoint);
      // Add all location predictions to the map
      data.locations.forEach((location, index) => {
        addPredictionToMap(location, index === 0, index + 1);
      });
      // Display the locations list
      displayPredictionsList(data.locations);
      // Display the uploaded image in the results
      displayUploadedImage(imageDataUrl);
      // Add waypoint list to UI
      updateWaypointsList();
      // Show the result section
      document.getElementById('resultSection').style.display = 'block';
    });
  } else {
    showError('No location predictions received');
  }
}

// Address form submit handler
async function addressFormSubmit(event) {
  event.preventDefault();
  
  // Get the address from the form
  const address = document.getElementById('address').value.trim();
  
  if (!address) {
    showError('Please enter an address');
    return;
  }
  
  try {
    // Clear previous error (if any)
    hideError();
    
    // Show loading state
    const submitButton = this.querySelector('button[type="submit"]');
    const originalText = submitButton.innerHTML;
    submitButton.disabled = true;
    submitButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Processing...';
    
    // Step 1: Geocode the address
    const geocodeResult = await geocodeAddress(address);
    
    // Step 2: Send coordinates to Skydio API to create a waypoint (just for status reporting)
    const waypointResult = await createWaypoint(geocodeResult.lat, geocodeResult.lng, geocodeResult.address);
    
    // Update the UI with the results
    document.getElementById('formattedAddress').textContent = geocodeResult.address;
    document.getElementById('coordinates').textContent = `${geocodeResult.lat.toFixed(6)}, ${geocodeResult.lng.toFixed(6)}`;
    
    if (waypointResult.simulation) {
      document.getElementById('waypointStatus').textContent = 'Waypoint added to map. Use Export button to save.';
    } else {
      document.getElementById('waypointStatus').textContent = 'Waypoint created successfully';
    }
    
    // Add the waypoint to our collection
    const newWaypoint = {
      lat: geocodeResult.lat,
      lng: geocodeResult.lng,
      address: geocodeResult.address,
      name: `Waypoint ${waypoints.length + 1}`,
      altitude: 50
    };
    waypoints.push(newWaypoint);
    
    // Update the map and UI
    addWaypointToMap(newWaypoint);
    updateWaypointsList();
    
    // Show the result section
    document.getElementById('resultSection').style.display = 'block';
    
    // Reset button state
    submitButton.disabled = false;
    submitButton.innerHTML = originalText;
    
    // Clear the address input for the next waypoint
    document.getElementById('address').value = '';
    
  } catch (error) {
    showError(error.message || 'An error occurred.');
    
    // Reset button state
    const submitButton = this.querySelector('button[type="submit"]');
    submitButton.disabled = false;
    submitButton.innerHTML = '<i class="bi bi-geo-alt"></i> Create Waypoint';
  }
}

// Image form submit handler
async function imageFormSubmit(event) {
  event.preventDefault();
  
  // City will always be San Francisco
  const city = 'San Francisco';
  
  if (!selectedImage) {
    showError('Please upload an image');
    return;
  }
  
  try {
    // Clear previous error (if any)
    hideError();
    
    // Show loading state
    const submitButton = this.querySelector('button[type="submit"]');
    if (!submitButton) {
      console.error("Submit button not found");
      showError('Form submission error. Please try again.');
      return;
    }
    
    const originalText = submitButton.innerHTML;
    submitButton.disabled = true;
    submitButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Analyzing image...';
    
    // Create a FormData object and append the image and city
    const formData = new FormData();
    formData.append('image', selectedImage);
    formData.append('city', city);
    
    console.log("Submitting image:", selectedImage.name, "Size:", selectedImage.size);
    
    // Send the image to the backend for OpenAI analysis
    const response = await fetch('/api/analyze-image', {
      method: 'POST',
      body: formData
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'Failed to analyze image');
    }
    
    const data = await response.json();
    console.log("Received analysis data:", data);
    
    // Save the image data to display in results
    const previewImg = document.getElementById('previewImg');
    const imageDataUrl = previewImg ? previewImg.src : null;
    
    if (!imageDataUrl) {
      console.error("Image preview not found");
    }
    
    // Clear existing markers
    markers.forEach(marker => marker.setMap(null));
    markers = [];
    
    // Close any open info windows
    infoWindows.forEach(infoWindow => infoWindow.close());
    infoWindows = [];
    
    // If the response has multiple locations
    if (data.locations && Array.isArray(data.locations)) {
      // Use the first (highest confidence) location as the primary
      const primaryLocation = data.locations[0];
      
      // Use the analyzed location to create a waypoint
      const waypointResult = await createWaypoint(primaryLocation.lat, primaryLocation.lng, primaryLocation.location_description);
      
      // Update the UI with the results
      document.getElementById('formattedAddress').textContent = primaryLocation.location_description;
      document.getElementById('coordinates').textContent = `${primaryLocation.lat.toFixed(6)}, ${primaryLocation.lng.toFixed(6)}`;
      
      if (waypointResult.simulation) {
        document.getElementById('waypointStatus').textContent = 'Waypoint added to map. Use Export button to save.';
      } else {
        document.getElementById('waypointStatus').textContent = 'Waypoint created successfully';
      }
      
      // Add the waypoint to our collection
      const newWaypoint = {
        lat: primaryLocation.lat,
        lng: primaryLocation.lng,
        address: primaryLocation.location_description,
        name: `Waypoint ${waypoints.length + 1}`,
        altitude: 50
      };
      waypoints.push(newWaypoint);
      
      // Add all location predictions to the map
      data.locations.forEach((location, index) => {
        addPredictionToMap(location, index === 0, index + 1);
      });
      
      // Display the locations list
      displayPredictionsList(data.locations);
      
      // Display the uploaded image in the results
      if (imageDataUrl) {
        displayUploadedImage(imageDataUrl);
      }
      
      // Add waypoint list to UI
      updateWaypointsList();
      
      // Show the result section
      document.getElementById('resultSection').style.display = 'block';
    } else {
      throw new Error('No location predictions received');
    }
    
    // Reset button state
    submitButton.disabled = false;
    submitButton.innerHTML = originalText;
    
    // Don't clear the form until the user wants to submit a new image
    
  } catch (error) {
    console.error("Image analysis error:", error);
    showError(error.message || 'An error occurred.');
    
    // Reset button state
    const submitButton = this.querySelector('button[type="submit"]');
    if (submitButton) {
      submitButton.disabled = false;
      submitButton.innerHTML = '<i class="bi bi-search"></i> Analyze Image & Create Waypoint';
    }
  }
}

// Update the waypoints list
function updateWaypointsList() {
  const waypointsContainer = document.getElementById('waypointsList');
  
  // Clear the container
  waypointsContainer.innerHTML = '';
  
  // Create waypoint items
  waypoints.forEach((waypoint, index) => {
    const waypointElement = document.createElement('div');
    waypointElement.className = 'incident-item';
    
    const iconColor = index === 0 ? 'var(--skydio-accent)' : 'var(--skydio-success)';
    
    waypointElement.innerHTML = `
      <div class="incident-icon" style="background-color: ${iconColor}">
        <i class="bi bi-geo-alt-fill"></i>
      </div>
      <div class="incident-details">
        <div class="incident-title">${waypoint.name}</div>
        <div class="incident-meta">${waypoint.address.substring(0, 50)}${waypoint.address.length > 50 ? '...' : ''}</div>
      </div>
      <div class="incident-time">
        <button class="remove-waypoint" data-index="${index}">
          <i class="bi bi-x"></i>
        </button>
      </div>
    `;
    
    waypointsContainer.appendChild(waypointElement);
  });
  
  // Add event listeners to remove buttons
  document.querySelectorAll('.remove-waypoint').forEach(button => {
    button.addEventListener('click', function() {
      const index = parseInt(this.getAttribute('data-index'));
      removeWaypoint(index);
    });
  });
  
  // Add click handlers for the waypoint items
  document.querySelectorAll('.incident-item').forEach((item, index) => {
    item.addEventListener('click', function(event) {
      // Don't trigger if the remove button was clicked
      if (event.target.closest('.remove-waypoint')) {
        return;
      }
      
      // Center map on this waypoint
      const waypoint = waypoints[index];
      map.setCenter({lat: waypoint.lat, lng: waypoint.lng});
      map.setZoom(17);
      
      // Trigger click on corresponding marker
      google.maps.event.trigger(markers[index], 'click');
      
      // Open Street View at this waypoint location
      openStreetView(waypoint.lat, waypoint.lng);
    });
  });
}

// Add a prediction marker to the map
function addPredictionToMap(prediction, isPrimary, index) {
  const position = {
    lat: parseFloat(prediction.lat),
    lng: parseFloat(prediction.lng)
  };
  
  // Center the map on the primary location
  if (isPrimary) {
    map.setCenter(position);
    map.setZoom(15);
  }
  
  // Create a custom SVG marker
  const markerColor = isPrimary ? '#f7b500' : '#4da3ff';
  const svgMarker = {
    path: 'M12,11.5A2.5,2.5 0 0,1 9.5,9A2.5,2.5 0 0,1 12,6.5A2.5,2.5 0 0,1 14.5,9A2.5,2.5 0 0,1 12,11.5M12,2A7,7 0 0,0 5,9C5,14.25 12,22 12,22C12,22 19,14.25 19,9A7,7 0 0,0 12,2Z',
    fillColor: markerColor,
    fillOpacity: 1,
    strokeWeight: 1,
    strokeColor: '#FFFFFF',
    rotation: 0,
    scale: 2,
    anchor: new google.maps.Point(12, 22),
    labelOrigin: new google.maps.Point(12, 9)
  };
  
  // Create a new marker
  const marker = new google.maps.Marker({
    position: position,
    map: map,
    title: prediction.location_description,
    animation: google.maps.Animation.DROP,
    icon: svgMarker,
    label: {
      text: String(index),
      color: '#FFFFFF',
      fontSize: '11px',
      fontWeight: 'bold'
    }
  });
  
  // Add the marker to our array
  markers.push(marker);
  
  // Calculate confidence percentage
  const confidencePercent = prediction.confidence.toFixed(1);
  
  // Create marker popup content
  const infoWindowContent = `
    <div class="marker-details">
      <div class="marker-header">${isPrimary ? 'Primary Location' : 'Alternative Location'} #${index}</div>
      <div class="marker-content">
        <strong>${prediction.location_description}</strong><br>
        <div style="margin: 5px 0">
          <small>Confidence: ${confidencePercent}%</small><br>
          <small>${position.lat.toFixed(6)}, ${position.lng.toFixed(6)}</small>
        </div>
      </div>
      <div class="marker-footer">
        <button class="marker-action" onclick="openStreetView(${position.lat}, ${position.lng})">
          <i class="bi bi-signpost-2"></i> Street View
        </button>
        <button class="marker-action primary" onclick="selectWaypoint(${position.lat}, ${position.lng}, '${prediction.location_description.replace(/'/g, "\\'")}')">
          <i class="bi bi-geo-alt"></i> Select
        </button>
      </div>
    </div>
  `;
  
  // Add an info window
  const infoWindow = new google.maps.InfoWindow({
    content: infoWindowContent
  });
  
  infoWindows.push(infoWindow);
  
  marker.addListener('click', function() {
    // Close all other info windows
    infoWindows.forEach(iw => iw !== infoWindow && iw.close());
    
    infoWindow.open(map, marker);
  });
  
  // Initially open the info window for primary location
  if (isPrimary) {
    infoWindow.open(map, marker);
  }
}

// Open Street View at the specified location
function openStreetView(lat, lng) {
  console.log('Opening Street View at:', lat, lng);
  const position = {lat, lng};
  
  // Get the image container
  const uploadedImageContainer = document.getElementById('uploadedImageContainer');
  if (!uploadedImageContainer) {
    console.error('Image container not found');
    return;
  }
  
  // Check if street view panel exists, if not create it
  let streetViewPanel = document.getElementById('street-view-panel');
  if (!streetViewPanel) {
    // Create the street view panel
    streetViewPanel = document.createElement('div');
    streetViewPanel.id = 'street-view-panel';
    streetViewPanel.style.height = '400px';
    streetViewPanel.style.width = '100%';
    
    // Add a title
    const title = document.createElement('div');
    title.className = 'image-title';
    title.textContent = 'Street View';
    streetViewPanel.appendChild(title);
    
    // Create the street view container
    const panoramaDiv = document.createElement('div');
    panoramaDiv.id = 'street-view';
    panoramaDiv.style.height = '100%';
    panoramaDiv.style.width = '100%';
    streetViewPanel.appendChild(panoramaDiv);
    
    // Add to the image container
    uploadedImageContainer.innerHTML = ''; // Clear existing content
    uploadedImageContainer.appendChild(streetViewPanel);
  } else {
    // Show the street view panel
    streetViewPanel.style.display = 'block';
    
    // Check if street view div exists
    let panoramaDiv = document.getElementById('street-view');
    if (!panoramaDiv) {
      // Create the street view container
      panoramaDiv = document.createElement('div');
      panoramaDiv.id = 'street-view';
      panoramaDiv.style.height = '100%';
      panoramaDiv.style.width = '100%';
      streetViewPanel.appendChild(panoramaDiv);
    }
    
    // Hide any existing result image
    const existingResultImage = document.getElementById('resultImage');
    if (existingResultImage) {
      existingResultImage.style.display = 'none';
    }
  }
  
  // Make sure the street view panel is visible by removing any hiding style
  streetViewPanel.style.display = 'block';
  
  // Clear the container except for the street view panel
  const children = Array.from(uploadedImageContainer.children);
  children.forEach(child => {
    if (child.id !== 'street-view-panel') {
      uploadedImageContainer.removeChild(child);
    }
  });
  
  // Make sure the street-view div exists before initializing
  const panoramaDiv = document.getElementById('street-view');
  if (!panoramaDiv) {
    console.error('Street view div not found');
    return;
  }
  
  // Ensure the div has dimensions to render the panorama
  panoramaDiv.style.height = '350px';
  panoramaDiv.style.width = '100%';
  
  // Force a layout redraw
  setTimeout(() => {
    console.log('Initializing Street View panorama');
    try {
      // Initialize the street view panorama
      panorama = new google.maps.StreetViewPanorama(
        panoramaDiv,
        {
          position: position,
          pov: {
            heading: 34,
            pitch: 10
          },
          visible: true
        }
      );
      
      // Check if Street View is available at this location
      const streetViewService = new google.maps.StreetViewService();
      streetViewService.getPanorama({ location: position, radius: 50 }, (data, status) => {
        console.log('Street View service response:', status);
        if (status === 'OK') {
          // Street view exists, update the POV
          panorama.setPov({
            heading: google.maps.geometry.spherical.computeHeading(
              data.location.latLng, 
              new google.maps.LatLng(position)
            ),
            pitch: 0
          });
        } else {
          // No street view available
          console.error('Street View is not available at this location');
          
          // Display an error message in the image container
          uploadedImageContainer.innerHTML = `
            <div class="image-title">Street View</div>
            <div class="no-street-view-message">
              <i class="bi bi-exclamation-triangle"></i>
              <p>Street View is not available at this location.</p>
            </div>
          `;
        }
      });
    } catch (e) {
      console.error('Error initializing Street View:', e);
    }
  }, 100);
}

// Select a waypoint from a marker
function selectWaypoint(lat, lng, location) {
  // Create a waypoint from the selected prediction
  const newWaypoint = {
    lat: lat,
    lng: lng,
    address: location,
    name: `Waypoint ${waypoints.length + 1}`,
    altitude: 50
  };
  
  // Add to waypoints array
  waypoints.push(newWaypoint);
  
  // Update the waypoints list
  updateWaypointsList();
  
  // Show success message
  alert(`Added "${location}" to waypoints list`);
}

// Display the list of location predictions
function displayPredictionsList(locations) {
  // Prepare the container
  const predictionsContainer = document.getElementById('predictionsContainer');
  predictionsContainer.innerHTML = '';
  
  // Create the predictions container
  const predictionsSection = document.createElement('div');
  predictionsSection.className = 'predictions-container';
  
  // Add a header
  const header = document.createElement('div');
  header.className = 'predictions-header';
  header.innerHTML = `<i class="bi bi-geo"></i> Probable Locations (${locations.length})`;
  predictionsSection.appendChild(header);
  
  // Add the predictions
  locations.forEach((location, index) => {
    const predictionItem = document.createElement('div');
    predictionItem.className = index === 0 ? 'prediction-item primary-prediction' : 'prediction-item';
    
    // Format confidence as percentage
    const confidence = location.confidence.toFixed(1);
    const confidenceClass = confidence > 80 ? 'badge-success' : (confidence > 50 ? 'badge-primary' : 'badge-warning');
    
    predictionItem.innerHTML = `
      <div class="prediction-content d-flex align-items-center">
        <span class="badge ${confidenceClass}">${index + 1}</span>
        <div class="prediction-details">
          <div class="prediction-location">${location.location_description}</div>
          <div class="prediction-meta">
            <div class="prediction-confidence">Confidence: ${confidence}%</div>
            <div class="prediction-coordinates">${location.lat.toFixed(6)}, ${location.lng.toFixed(6)}</div>
          </div>
        </div>
      </div>
      <div class="prediction-actions">
        <button class="btn btn-sm btn-outline-primary zoom-to-location" data-index="${index}">
          <i class="bi bi-geo-alt"></i>
        </button>
      </div>
    `;
    
    predictionsSection.appendChild(predictionItem);
  });
  
  // Add to the container
  predictionsContainer.appendChild(predictionsSection);
  
  // Add click handlers for the items and view buttons
  document.querySelectorAll('.prediction-item').forEach((item, index) => {
    // Click on the whole item
    item.addEventListener('click', function(event) {
      // Don't trigger if the button was clicked 
      if (event.target.closest('.btn')) {
        return;
      }
      zoomToLocation(index);
    });
  });
  
  // Specific button clicks
  document.querySelectorAll('.zoom-to-location').forEach(button => {
    button.addEventListener('click', function() {
      const index = parseInt(this.getAttribute('data-index'));
      zoomToLocation(index);
    });
  });
}

// Zoom to a specific prediction location
function zoomToLocation(index) {
  const marker = markers[index];
  
  // Focus on this location with animation
  map.panTo(marker.getPosition());
  map.setZoom(17);
  
  // Trigger a click on the marker to open the info window
  google.maps.event.trigger(marker, 'click');
  
  // Highlight the prediction in the list
  const items = document.querySelectorAll('.prediction-item');
  items.forEach(item => item.classList.remove('highlighted'));
  items[index].classList.add('highlighted');

  // Update Street View to this location
  const position = marker.getPosition();
  openStreetView(position.lat(), position.lng());
}

// Display the uploaded image in the results
function displayUploadedImage(imageDataUrl) {
  // Find or create the image container
  const imageContainer = document.getElementById('uploadedImageContainer');
  
  // Hide the street view panel if it exists
  const streetViewPanel = document.getElementById('street-view-panel');
  if (streetViewPanel) {
    streetViewPanel.style.display = 'none';
  }
  
  // Clear the container
  imageContainer.innerHTML = '';
  
  // Create a title
  const title = document.createElement('div');
  title.className = 'image-title';
  title.textContent = 'Uploaded Image';
  imageContainer.appendChild(title);
  
  // Create the image element
  const img = document.createElement('img');
  img.id = 'resultImage';
  img.className = 'img-fluid';
  img.src = imageDataUrl;
  imageContainer.appendChild(img);
}

// Geocode the address using our backend API
async function geocodeAddress(address) {
  try {
    const response = await fetch('/api/geocode', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ address })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'Failed to geocode address');
    }
    
    const data = await response.json();
    geocodedLat = data.lat;
    geocodedLng = data.lng;
    
    return {
      address: data.address,
      lat: data.lat,
      lng: data.lng
    };
  } catch (error) {
    console.error('Geocoding error:', error);
    throw new Error(error.message || 'Failed to geocode address');
  }
}

// Create a waypoint using our backend API
async function createWaypoint(lat, lng, address) {
  try {
    const response = await fetch('/api/waypoint', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        lat,
        lng,
        address
      })
    });
    
    const data = await response.json();
    
    if (!response.ok && !data.simulation) {
      throw new Error(data.error || 'Failed to create waypoint');
    }
    
    return data;
  } catch (error) {
    console.error('Waypoint creation error:', error);
    throw new Error(error.message || 'Failed to create waypoint');
  }
}

// Add a waypoint to the map
function addWaypointToMap(waypoint) {
  const position = {
    lat: parseFloat(waypoint.lat),
    lng: parseFloat(waypoint.lng)
  };
  
  // Center the map on the location
  map.setCenter(position);
  map.setZoom(15);
  
  // Create SVG marker for the waypoint
  const svgMarker = {
    path: 'M12,11.5A2.5,2.5 0 0,1 9.5,9A2.5,2.5 0 0,1 12,6.5A2.5,2.5 0 0,1 14.5,9A2.5,2.5 0 0,1 12,11.5M12,2A7,7 0 0,0 5,9C5,14.25 12,22 12,22C12,22 19,14.25 19,9A7,7 0 0,0 12,2Z',
    fillColor: '#f7b500',
    fillOpacity: 1,
    strokeWeight: 1,
    strokeColor: '#FFFFFF',
    rotation: 0,
    scale: 2,
    anchor: new google.maps.Point(12, 22),
    labelOrigin: new google.maps.Point(12, 9)
  };
  
  // Create a new marker
  const marker = new google.maps.Marker({
    position: position,
    map: map,
    title: waypoint.address,
    animation: google.maps.Animation.DROP,
    icon: svgMarker,
    label: {
      text: String(waypoints.length),
      color: '#FFFFFF',
      fontSize: '11px',
      fontWeight: 'bold'
    }
  });
  
  // Add the marker to our array
  markers.push(marker);
  
  // Create marker info window content
  const infoWindowContent = `
    <div class="marker-details">
      <div class="marker-header">${waypoint.name}</div>
      <div class="marker-content">
        <strong>${waypoint.address}</strong><br>
        <div style="margin: 5px 0">
          <small>Lat: ${position.lat.toFixed(6)}</small><br>
          <small>Lng: ${position.lng.toFixed(6)}</small>
        </div>
      </div>
      <div class="marker-footer">
        <button class="marker-action" onclick="openStreetView(${position.lat}, ${position.lng})">
          <i class="bi bi-signpost-2"></i> Street View
        </button>
      </div>
    </div>
  `;
  
  // Add an info window
  const infoWindow = new google.maps.InfoWindow({
    content: infoWindowContent
  });
  
  infoWindows.push(infoWindow);
  
  marker.addListener('click', function() {
    // Close all other info windows
    infoWindows.forEach(iw => iw !== infoWindow && iw.close());
    
    infoWindow.open(map, marker);
  });
  
  // Initially open the info window
  infoWindow.open(map, marker);
  
  // Draw lines between waypoints if we have multiple
  if (waypoints.length > 1) {
    drawPathOnMap();
  }
  
  // Automatically open Street View for this waypoint
  openStreetView(position.lat, position.lng);
}

// Draw path between waypoints
function drawPathOnMap() {
  // Remove any existing path
  if (window.pathLine) {
    window.pathLine.setMap(null);
  }
  
  // Create an array of LatLng points
  const pathCoordinates = waypoints.map(wp => ({
    lat: parseFloat(wp.lat),
    lng: parseFloat(wp.lng)
  }));
  
  // Create the path
  window.pathLine = new google.maps.Polyline({
    path: pathCoordinates,
    geodesic: true,
    strokeColor: '#00a0f5',
    strokeOpacity: 0.8,
    strokeWeight: 3
  });
  
  window.pathLine.setMap(map);
  
  // Show simulation button if we have at least 2 waypoints
  if (waypoints.length >= 2) {
    showSimulationButton();
  } else {
    hideSimulationButton();
  }
}

// Add a function to show the simulation button
function showSimulationButton() {
  // Check if simulation button already exists
  if (!document.getElementById('simulateFlightBtn')) {
    // Create the simulate button
    const simulateButton = document.createElement('button');
    simulateButton.id = 'simulateFlightBtn';
    simulateButton.textContent = 'Simulate Flight';
    simulateButton.className = 'custom-map-button';
    simulateButton.style.backgroundColor = '#f7b500'; // Skydio yellow/orange color
    simulateButton.addEventListener('click', toggleFlightSimulation);
    
    // Add to the map controls
    map.controls[google.maps.ControlPosition.TOP_RIGHT].push(simulateButton);
  } else {
    // Show existing button
    document.getElementById('simulateFlightBtn').style.display = 'block';
  }
}

// Add a function to hide the simulation button
function hideSimulationButton() {
  const simulateButton = document.getElementById('simulateFlightBtn');
  if (simulateButton) {
    simulateButton.style.display = 'none';
  }
}

// Toggle flight simulation
function toggleFlightSimulation() {
  if (!simulationInProgress) {
    startFlightSimulation();
  } else if (simulationPaused) {
    resumeFlightSimulation();
  } else {
    pauseFlightSimulation();
  }
}

// Start the flight simulation
function startFlightSimulation() {
  if (waypoints.length < 2) {
    alert('You need at least 2 waypoints to simulate a flight.');
    return;
  }
  
  // Create simulation controls panel if it doesn't exist
  createSimulationControlsPanel();
  
  // Reset simulation variables
  currentLeg = 0;
  legProgress = 0;
  simulationInProgress = true;
  simulationPaused = false;
  
  // Create the drone marker if it doesn't exist
  if (!droneMarker) {
    // Custom drone SVG icon
    const droneSvg = {
      path: 'M18,4L12,0L6,4L0,2L0,7L6,9L12,5L18,9L24,7V2L18,4Z M18,12L12,8L6,12L0,10L0,15L6,17L12,13L18,17L24,15V10L18,12Z',
      fillColor: '#f7b500',
      fillOpacity: 1,
      strokeWeight: 1,
      strokeColor: '#FFFFFF',
      rotation: 0,
      scale: 1.2,
      anchor: new google.maps.Point(12, 8.5)
    };
    
    // Create the marker at the first waypoint
    droneMarker = new google.maps.Marker({
      position: {
        lat: parseFloat(waypoints[0].lat),
        lng: parseFloat(waypoints[0].lng)
      },
      map: map,
      icon: droneSvg,
      title: 'Drone',
      zIndex: 1000
    });
  } else {
    // Reset the drone position to the first waypoint
    droneMarker.setPosition({
      lat: parseFloat(waypoints[0].lat),
      lng: parseFloat(waypoints[0].lng)
    });
    droneMarker.setMap(map);
  }
  
  // Update the simulation button
  const simulateButton = document.getElementById('simulateFlightBtn');
  if (simulateButton) {
    simulateButton.textContent = 'Pause Flight';
  }
  
  // Start the animation
  animateFlightPath();
  
  // Show simulation info panel
  updateSimulationInfo(0);
}

// Pause the flight simulation
function pauseFlightSimulation() {
  simulationPaused = true;
  
  // Cancel the animation frame
  if (simulationAnimationId) {
    cancelAnimationFrame(simulationAnimationId);
    simulationAnimationId = null;
  }
  
  // Update the button text
  const simulateButton = document.getElementById('simulateFlightBtn');
  if (simulateButton) {
    simulateButton.textContent = 'Resume Flight';
  }
  
  // Update controls
  const playPauseBtn = document.getElementById('simPlayPauseBtn');
  if (playPauseBtn) {
    playPauseBtn.innerHTML = '<i class="bi bi-play-fill"></i>';
  }
}

// Resume the flight simulation
function resumeFlightSimulation() {
  simulationPaused = false;
  
  // Restart the animation
  animateFlightPath();
  
  // Update the button text
  const simulateButton = document.getElementById('simulateFlightBtn');
  if (simulateButton) {
    simulateButton.textContent = 'Pause Flight';
  }
  
  // Update controls
  const playPauseBtn = document.getElementById('simPlayPauseBtn');
  if (playPauseBtn) {
    playPauseBtn.innerHTML = '<i class="bi bi-pause-fill"></i>';
  }
}

// Stop the flight simulation
function stopFlightSimulation() {
  simulationInProgress = false;
  simulationPaused = false;
  
  // Cancel the animation frame
  if (simulationAnimationId) {
    cancelAnimationFrame(simulationAnimationId);
    simulationAnimationId = null;
  }
  
  // Remove the drone marker
  if (droneMarker) {
    droneMarker.setMap(null);
  }
  
  // Update the button text
  const simulateButton = document.getElementById('simulateFlightBtn');
  if (simulateButton) {
    simulateButton.textContent = 'Simulate Flight';
  }
  
  // Hide the simulation panel
  const simPanel = document.getElementById('simulationControlsPanel');
  if (simPanel) {
    simPanel.style.display = 'none';
  }
}

// Create the simulation controls panel
function createSimulationControlsPanel() {
  // Check if panel already exists
  let simPanel = document.getElementById('simulationControlsPanel');
  
  if (!simPanel) {
    // Create the panel
    simPanel = document.createElement('div');
    simPanel.id = 'simulationControlsPanel';
    simPanel.className = 'simulation-panel';
    simPanel.innerHTML = `
      <div class="simulation-header">
        <h6>Flight Simulation</h6>
        <button id="simCloseBtn" class="sim-close-btn"><i class="bi bi-x"></i></button>
      </div>
      <div class="simulation-info">
        <div class="sim-info-row">
          <span>Current Waypoint:</span>
          <span id="simCurrentWaypoint">1 of ${waypoints.length}</span>
        </div>
        <div class="sim-info-row">
          <span>Altitude:</span>
          <span id="simAltitude">50 m</span>
        </div>
        <div class="sim-info-row">
          <span>Speed:</span>
          <span id="simSpeed">${simulationSpeed} m/s</span>
        </div>
        <div class="sim-info-row">
          <span>ETA:</span>
          <span id="simEta">Calculating...</span>
        </div>
      </div>
      <div class="simulation-controls">
        <div class="speed-control">
          <label for="simSpeedControl">Speed:</label>
          <input type="range" id="simSpeedControl" min="10" max="100" value="${simulationSpeed}" step="5">
          <span id="simSpeedValue">${simulationSpeed} m/s</span>
        </div>
        <div class="sim-buttons">
          <button id="simPlayPauseBtn" class="sim-btn"><i class="bi bi-pause-fill"></i></button>
          <button id="simStopBtn" class="sim-btn"><i class="bi bi-stop-fill"></i></button>
        </div>
      </div>
    `;
    
    // Add CSS for the panel
    const style = document.createElement('style');
    style.textContent = `
      .simulation-panel {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 300px;
        background-color: rgba(30, 39, 50, 0.9);
        color: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        font-family: 'Inter', sans-serif;
        overflow: hidden;
      }
      .simulation-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 15px;
        background-color: #0a1017;
        border-bottom: 1px solid #2c3e50;
      }
      .simulation-header h6 {
        margin: 0;
        font-weight: 600;
        color: #f7b500;
      }
      .sim-close-btn {
        background: none;
        border: none;
        color: white;
        font-size: 16px;
        cursor: pointer;
        padding: 0;
      }
      .simulation-info {
        padding: 10px 15px;
        border-bottom: 1px solid #2c3e50;
      }
      .sim-info-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        font-size: 14px;
      }
      .simulation-controls {
        padding: 10px 15px;
      }
      .speed-control {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
        font-size: 14px;
      }
      .speed-control label {
        margin-right: 10px;
      }
      .speed-control input {
        flex-grow: 1;
        margin: 0 10px;
      }
      .sim-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
      }
      .sim-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: #2c3e50;
        border: none;
        color: white;
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }
      .sim-btn:hover {
        background-color: #3d5166;
      }
    `;
    document.head.appendChild(style);
    
    // Add the panel to the document
    document.body.appendChild(simPanel);
    
    // Add event listeners
    document.getElementById('simCloseBtn').addEventListener('click', stopFlightSimulation);
    document.getElementById('simPlayPauseBtn').addEventListener('click', toggleFlightSimulation);
    document.getElementById('simStopBtn').addEventListener('click', stopFlightSimulation);
    
    // Speed control
    const speedControl = document.getElementById('simSpeedControl');
    const speedValue = document.getElementById('simSpeedValue');
    
    speedControl.addEventListener('input', function() {
      simulationSpeed = parseInt(this.value);
      speedValue.textContent = `${simulationSpeed} m/s`;
      document.getElementById('simSpeed').textContent = `${simulationSpeed} m/s`;
      
      // Recalculate ETA
      updateSimulationInfo(currentLeg);
    });
  } else {
    // Show existing panel
    simPanel.style.display = 'block';
    
    // Update waypoint count
    document.getElementById('simCurrentWaypoint').textContent = `1 of ${waypoints.length}`;
    
    // Reset speed to default
    document.getElementById('simSpeedControl').value = simulationSpeed;
    document.getElementById('simSpeedValue').textContent = `${simulationSpeed} m/s`;
    document.getElementById('simSpeed').textContent = `${simulationSpeed} m/s`;
    
    // Update ETA
    updateSimulationInfo(0);
  }
}

// Animate the drone along the flight path
function animateFlightPath() {
  if (!simulationInProgress || simulationPaused) {
    return;
  }
  
  // Get path coordinates
  const path = waypoints.map(wp => ({
    lat: parseFloat(wp.lat),
    lng: parseFloat(wp.lng)
  }));
  
  // If we've reached the end
  if (currentLeg >= path.length - 1) {
    // We've completed the journey
    stopFlightSimulation();
    alert('Flight simulation completed!');
    return;
  }
  
  // Get current leg points
  const start = path[currentLeg];
  const end = path[currentLeg + 1];
  
  // Interpolate position based on progress
  const position = google.maps.geometry.spherical.interpolate(
    new google.maps.LatLng(start.lat, start.lng),
    new google.maps.LatLng(end.lat, end.lng),
    legProgress
  );
  
  // Update drone position
  droneMarker.setPosition(position);
  
  // Calculate forward direction for icon rotation
  const heading = google.maps.geometry.spherical.computeHeading(
    new google.maps.LatLng(start.lat, start.lng),
    new google.maps.LatLng(end.lat, end.lng)
  );
  
  // Update drone icon rotation
  const icon = droneMarker.getIcon();
  icon.rotation = heading;
  droneMarker.setIcon(icon);
  
  // Center map on drone if following
  map.panTo(position);
  
  // Calculate the distance for this leg
  const legDistance = google.maps.geometry.spherical.computeDistanceBetween(
    new google.maps.LatLng(start.lat, start.lng),
    new google.maps.LatLng(end.lat, end.lng)
  );
  
  // Calculate how much progress to make based on speed and time
  const timeIncrement = 1/60; // 60 fps
  const distancePerFrame = simulationSpeed * timeIncrement;
  const progressIncrement = distancePerFrame / legDistance;
  
  // Update progress
  legProgress += progressIncrement;
  
  // Update altitude based on waypoint altitude difference
  const startAlt = waypoints[currentLeg].altitude || 50;
  const endAlt = waypoints[currentLeg + 1].altitude || 50;
  const currentAlt = startAlt + (endAlt - startAlt) * legProgress;
  
  // Update simulation info
  document.getElementById('simAltitude').textContent = `${Math.round(currentAlt)} m`;
  
  // If we've completed this leg
  if (legProgress >= 1) {
    // Move to next leg
    currentLeg++;
    legProgress = 0;
    
    // Update waypoint info
    updateSimulationInfo(currentLeg);
    
    // If we reach a waypoint, make the marker bounce
    if (currentLeg < path.length) {
      const waypointMarker = markers[currentLeg];
      if (waypointMarker) {
        waypointMarker.setAnimation(google.maps.Animation.BOUNCE);
        setTimeout(() => {
          waypointMarker.setAnimation(null);
        }, 1500);
      }
    }
  }
  
  // Continue animation
  simulationAnimationId = requestAnimationFrame(animateFlightPath);
}

// Update simulation info panel
function updateSimulationInfo(currentWaypointIndex) {
  // Update current waypoint
  document.getElementById('simCurrentWaypoint').textContent = `${currentWaypointIndex + 1} of ${waypoints.length}`;
  
  // Calculate total distance remaining
  let totalDistance = 0;
  for (let i = currentWaypointIndex; i < waypoints.length - 1; i++) {
    const start = {
      lat: parseFloat(waypoints[i].lat),
      lng: parseFloat(waypoints[i].lng)
    };
    const end = {
      lat: parseFloat(waypoints[i + 1].lat),
      lng: parseFloat(waypoints[i + 1].lng)
    };
    
    totalDistance += google.maps.geometry.spherical.computeDistanceBetween(
      new google.maps.LatLng(start.lat, start.lng),
      new google.maps.LatLng(end.lat, end.lng)
    );
  }
  
  // Calculate ETA based on distance and speed
  const etaSeconds = totalDistance / simulationSpeed;
  let etaText;
  
  if (etaSeconds < 60) {
    etaText = `${Math.round(etaSeconds)} sec`;
  } else if (etaSeconds < 3600) {
    const minutes = Math.floor(etaSeconds / 60);
    const seconds = Math.round(etaSeconds % 60);
    etaText = `${minutes}:${seconds.toString().padStart(2, '0')} min`;
  } else {
    const hours = Math.floor(etaSeconds / 3600);
    const minutes = Math.floor((etaSeconds % 3600) / 60);
    etaText = `${hours}:${minutes.toString().padStart(2, '0')} hr`;
  }
  
  document.getElementById('simEta').textContent = etaText;
}

// Clear all waypoints
function clearAllWaypoints() {
  // Ask for confirmation
  if (!confirm('Are you sure you want to clear all waypoints?')) {
    return;
  }
  
  // Stop any ongoing simulation
  if (simulationInProgress) {
    stopFlightSimulation();
  }
  
  // Remove all markers from the map
  markers.forEach(marker => {
    marker.setMap(null);
  });
  
  // Clear the arrays
  markers = [];
  waypoints = [];
  
  // Remove the path
  if (window.pathLine) {
    window.pathLine.setMap(null);
  }
  
  // Update the UI
  updateWaypointsList();
  
  // Hide the result section if we have no waypoints
  if (waypoints.length === 0) {
    document.getElementById('resultSection').style.display = 'none';
  }
  
  // Hide the simulation button
  hideSimulationButton();
}

// Remove a specific waypoint
function removeWaypoint(index) {
  // Remove the marker from the map
  markers[index].setMap(null);
  
  // Remove from arrays
  waypoints.splice(index, 1);
  markers.splice(index, 1);
  
  // Update markers' labels
  markers.forEach((marker, i) => {
    if (marker.getLabel()) {
      marker.setLabel({
        text: String(i + 1),
        color: '#FFFFFF',
        fontSize: '11px',
        fontWeight: 'bold'
      });
    }
  });
  
  // Update the path
  if (waypoints.length > 1) {
    drawPathOnMap();
  } else if (window.pathLine) {
    window.pathLine.setMap(null);
  }
  
  // Update the UI
  updateWaypointsList();
  
  // Hide the result section if we have no waypoints
  if (waypoints.length === 0) {
    document.getElementById('resultSection').style.display = 'none';
  }
}

// Export waypoints in multiple formats
function exportWaypoints() {
  if (waypoints.length === 0) {
    showError('No waypoints to export');
    return;
  }
  
  // Create modal for export options if not exists
  if (!document.getElementById('exportModal')) {
    const modalHTML = `
      <div class="modal fade" id="exportModal" tabindex="-1" aria-labelledby="exportModalLabel" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title" id="exportModalLabel">Export Waypoints</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <p>Choose an export format:</p>
              <div class="d-grid gap-2">
                <button class="btn btn-outline-primary" id="exportKML">KML Format (Google Earth)</button>
                <button class="btn btn-outline-primary" id="exportGPX">GPX Format (GPS Exchange)</button>
                <button class="btn btn-outline-primary" id="exportCSV">CSV Format (Spreadsheet)</button>
                <button class="btn btn-outline-primary" id="exportJSON">JSON Format (Raw Data)</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
    
    const modalContainer = document.createElement('div');
    modalContainer.innerHTML = modalHTML;
    document.body.appendChild(modalContainer);
    
    // Add event listeners to export buttons
    document.getElementById('exportKML').addEventListener('click', () => {
      downloadWaypoints('kml');
      bootstrap.Modal.getInstance(document.getElementById('exportModal')).hide();
    });
    
    document.getElementById('exportGPX').addEventListener('click', () => {
      downloadWaypoints('gpx');
      bootstrap.Modal.getInstance(document.getElementById('exportModal')).hide();
    });
    
    document.getElementById('exportCSV').addEventListener('click', () => {
      downloadWaypoints('csv');
      bootstrap.Modal.getInstance(document.getElementById('exportModal')).hide();
    });
    
    document.getElementById('exportJSON').addEventListener('click', () => {
      downloadWaypoints('json');
      bootstrap.Modal.getInstance(document.getElementById('exportModal')).hide();
    });
  }
  
  // Show the modal
  const modal = new bootstrap.Modal(document.getElementById('exportModal'));
  modal.show();
}

// Download waypoints in the specified format
function downloadWaypoints(format) {
  let content = '';
  let mimeType = '';
  let extension = '';
  
  switch (format) {
    case 'kml':
      // Create KML content with workaround for tag names
      const nameTag = 'name'; // Use variables instead of direct tags
      content = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <${nameTag}>Skydio Waypoints</${nameTag}>
    <description>Waypoints exported from Skydio Waypoint Manager</description>
    <Style id="waypointStyle">
      <IconStyle>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/paddle/blu-circle.png</href>
        </Icon>
      </IconStyle>
    </Style>
${waypoints.map((wp, index) => `    <Placemark>
      <${nameTag}>Waypoint ${index + 1}</${nameTag}>
      <description>${wp.address}</description>
      <styleUrl>#waypointStyle</styleUrl>
      <Point>
        <coordinates>${wp.lng},${wp.lat},${wp.altitude || 50}</coordinates>
      </Point>
    </Placemark>`).join('\n')}
    <Placemark>
      <${nameTag}>Flight Path</${nameTag}>
      <LineString>
        <altitudeMode>relativeToGround</altitudeMode>
        <coordinates>
${waypoints.map(wp => `          ${wp.lng},${wp.lat},${wp.altitude || 50}`).join('\n')}
        </coordinates>
      </LineString>
    </Placemark>
  </Document>
</kml>`;
      mimeType = 'application/vnd.google-earth.kml+xml';
      extension = 'kml';
      break;
      
    case 'gpx':
      // Create GPX content with workaround for tag names
      const nameTagGpx = 'name'; // Use variables instead of direct tags
      content = `<?xml version="1.0" encoding="UTF-8"?>
<gpx xmlns="http://www.topografix.com/GPX/1/1" version="1.1" creator="Skydio Waypoint Manager">
  <metadata>
    <${nameTagGpx}>Skydio Waypoints</${nameTagGpx}>
    <desc>Waypoints exported from Skydio Waypoint Manager</desc>
  </metadata>
  <rte>
    <${nameTagGpx}>Skydio Flight Route</${nameTagGpx}>
${waypoints.map((wp, index) => `    <rtept lat="${wp.lat}" lon="${wp.lng}">
      <ele>${wp.altitude || 50}</ele>
      <${nameTagGpx}>Waypoint ${index + 1}</${nameTagGpx}>
      <desc>${wp.address}</desc>
    </rtept>`).join('\n')}
  </rte>
</gpx>`;
      mimeType = 'application/gpx+xml';
      extension = 'gpx';
      break;
      
    case 'csv':
      // Create CSV content
      content = 'Name,Latitude,Longitude,Altitude,Address\n';
      content += waypoints.map((wp, index) => 
        `"Waypoint ${index + 1}",${wp.lat},${wp.lng},${wp.altitude || 50},"${wp.address}"`
      ).join('\n');
      mimeType = 'text/csv';
      extension = 'csv';
      break;
      
    case 'json':
      // Create JSON content
      content = JSON.stringify({
        name: 'Skydio Waypoints',
        description: 'Waypoints exported from Skydio Waypoint Manager',
        waypoints: waypoints.map((wp, index) => ({
          id: index + 1,
          name: `Waypoint ${index + 1}`,
          lat: wp.lat,
          lng: wp.lng,
          altitude: wp.altitude || 50,
          address: wp.address
        })),
        created: new Date().toISOString()
      }, null, 2);
      mimeType = 'application/json';
      extension = 'json';
      break;
  }
  
  // Create file and trigger download
  const blob = new Blob([content], {type: mimeType});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `skydio_waypoints.${extension}`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Show error message
function showError(message) {
  const errorSection = document.getElementById('errorSection');
  const errorMessage = document.getElementById('errorMessage');
  
  errorMessage.textContent = message;
  errorSection.style.display = 'block';
}

// Hide error message
function hideError() {
  document.getElementById('errorSection').style.display = 'none';
}

// Fetch recent 911 calls from the API
async function fetchRecentCalls(limit = 50) {
  try {
    // Clear the calls list and show loading state
    const callsList = document.getElementById('callsList');
    callsList.innerHTML = `
      <div class="text-center p-4 text-muted">
        <div class="spinner-border spinner-border-sm" role="status">
          <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Loading 911 calls...</p>
      </div>
    `;
    
    // Fetch data from our API endpoint
    const response = await fetch(`/api/911-calls?limit=${limit}`);
    
    if (!response.ok) {
      throw new Error('Failed to fetch 911 calls data');
    }
    
    const data = await response.json();
    callsData = data; // Store for filtering
    
    // Display the calls in the UI
    displayCalls(data);
    
    // Display all calls on the map
    displayCallsOnMap(data);
    
    return data;
  } catch (error) {
    console.error('Error fetching 911 calls:', error);
    
    // Show error in the calls list
    const callsList = document.getElementById('callsList');
    callsList.innerHTML = `
      <div class="text-center p-4">
        <div class="alert alert-danger">
          <i class="bi bi-exclamation-triangle"></i>
          Failed to load 911 calls: ${error.message}
        </div>
        <button class="btn btn-primary btn-sm mt-2" onclick="fetchRecentCalls()">
          <i class="bi bi-arrow-clockwise"></i> Retry
        </button>
      </div>
    `;
  }
}

// Display 911 calls in the UI
function displayCalls(calls) {
  const callsList = document.getElementById('callsList');
  
  if (!calls || calls.length === 0) {
    callsList.innerHTML = `
      <div class="text-center p-4 text-muted">
        <i class="bi bi-inbox" style="font-size: 2rem;"></i>
        <p class="mt-2">No 911 calls found</p>
      </div>
    `;
    return;
  }
  
  // Clear existing content
  callsList.innerHTML = '';
  
  // Add each call to the list
  calls.forEach(call => {
    // Format date - use incident_datetime field
    const callDate = new Date(call.incident_datetime);
    const formattedDate = callDate.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });
    
    const formattedTime = callDate.toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit'
    });
    
    // Determine the appropriate icon based on incident type
    let iconClass = 'bi-telephone-fill';
    let severityValue = '';
    let priority = '';
    let priorityClass = '';
    let iconColor = '';
    
    // Determine priority based on incident description or category
    if (call.incident_category) {
      const category = call.incident_category.toLowerCase();
      if (category.includes('assault') || category.includes('weapon') || category.includes('robbery') || 
          category.includes('shooting') || category.includes('arson')) {
        priority = 'HIGH';
        priorityClass = 'priority-high';
        severityValue = 'high';
        iconColor = '#e74c3c'; // Red for high severity
      } else if (category.includes('theft') || category.includes('burglary') || 
                category.includes('vehicle') || category.includes('fraud')) {
        priority = 'MEDIUM';
        priorityClass = 'priority-medium';
        severityValue = 'medium';
        iconColor = '#f7b500'; // Yellow for medium severity
      } else {
        priority = 'LOW';
        priorityClass = 'priority-low';
        severityValue = 'low';
        iconColor = '#36b27c'; // Green for low severity
      }
    }
    
    // Choose icon based on incident type, but color based on severity
    if (call.incident_category) {
      const category = call.incident_category.toLowerCase();
      
      if (category.includes('assault') || category.includes('weapon')) {
        iconClass = 'bi-exclamation-triangle-fill';
      } else if (category.includes('theft') || category.includes('burglary') || category.includes('robbery')) {
        iconClass = 'bi-house-door-fill';
      } else if (category.includes('traffic collision') || 
                (category.includes('traffic') && category.includes('collision'))) {
        iconClass = 'bi-car-front-fill';
      } else if (category.includes('traffic') || category.includes('vehicle')) {
        iconClass = 'bi-car-front-fill';
      } else if (category.includes('fire')) {
        iconClass = 'bi-fire';
      } else if (category.includes('medical') || category.includes('ambulance')) {
        iconClass = 'bi-heart-pulse-fill';
      }
    } else if (call.incident_description) {
      const description = call.incident_description.toLowerCase();
      
      if (description.includes('traffic collision') || 
          (description.includes('traffic') && description.includes('collision'))) {
        iconClass = 'bi-car-front-fill';
      }
    }
    
    // Store severity value as a data attribute for filtering
    const coordinates = call.latitude && call.longitude ? 
      `${parseFloat(call.latitude).toFixed(6)}, ${parseFloat(call.longitude).toFixed(6)}` : 
      'No coordinates';
    
    // Create call item element
    const callItem = document.createElement('div');
    callItem.className = 'incident-item';
    callItem.setAttribute('data-severity', severityValue);
    
    // Create the icon container with style directly on the element
    const iconContainer = document.createElement('div');
    iconContainer.className = 'call-icon-container';
    
    // Create the icon element with inline style for color based on severity
    const iconElement = document.createElement('i');
    iconElement.className = `bi ${iconClass}`;
    if (iconColor) {
      iconElement.style.color = iconColor;
    }
    
    // Add a fallback class if iconClass is empty
    if (!iconClass || iconClass === 'bi-telephone-fill') {
      // For traffic collisions, ensure we have the car icon
      if ((call.incident_category && call.incident_category.toLowerCase().includes('traffic collision')) ||
          (call.incident_description && call.incident_description.toLowerCase().includes('traffic collision'))) {
        iconElement.className = 'bi bi-car-front-fill';
      }
    }
    
    // Debug the icon class
    console.log('Icon for:', call.incident_description || call.incident_category, 'Icon class:', iconClass);
    
    // Append icon to container
    iconContainer.appendChild(iconElement);
    
    // Create the incident details container
    const detailsContainer = document.createElement('div');
    detailsContainer.className = 'incident-details';
    detailsContainer.innerHTML = `
      <div class="incident-title">${call.incident_description || call.incident_category || 'Unknown Incident'}</div>
      <div class="incident-meta">
        ${formattedTime}
      </div>
      <div class="incident-info">
        <span class="incident-number">#${call.incident_number || call.incident_id || 'Unknown'}</span>
        <span class="incident-coords">${coordinates}</span>
      </div>
      <div class="incident-address">${call.intersection || 'No address'}</div>
    `;
    
    // Create the actions container
    const actionsContainer = document.createElement('div');
    actionsContainer.className = 'incident-actions';
    actionsContainer.innerHTML = `
      <span class="priority-badge ${priorityClass}">${priority}</span>
      <button class="btn-add-waypoint" title="Add as Waypoint" data-lat="${call.latitude || ''}" data-lng="${call.longitude || ''}">
        <i class="bi bi-plus-circle"></i>
      </button>
    `;
    
    // Append all containers to the call item
    callItem.appendChild(iconContainer);
    callItem.appendChild(detailsContainer);
    callItem.appendChild(actionsContainer);
    
    // Add call to waypoint functionality
    const addWaypointBtn = callItem.querySelector('.btn-add-waypoint');
    if (addWaypointBtn && call.latitude && call.longitude) {
      addWaypointBtn.addEventListener('click', function(e) {
        e.stopPropagation(); // Prevent triggering the call item click
        
        const lat = parseFloat(call.latitude);
        const lng = parseFloat(call.longitude);
        const description = call.incident_description || call.incident_category || 'Incident';
        const address = call.intersection || `Incident #${call.incident_number || call.incident_id}`;
        
        // Create waypoint
        const newWaypoint = {
          lat: lat,
          lng: lng,
          address: `${description} at ${address}`,
          name: `Waypoint ${waypoints.length + 1} (911 Call)`,
          altitude: 50
        };
        
        // Add to waypoints array
        waypoints.push(newWaypoint);
        
        // Update the map
        addWaypointToMap(newWaypoint);
        
        // Update the waypoints list UI
        updateWaypointsList();
        
        // Show notification
        alert(`Added 911 call as waypoint: ${description}`);
      });
    }
    
    // Add click handler for the whole incident item
    callItem.addEventListener('click', function() {
      const lat = parseFloat(call.latitude);
      const lng = parseFloat(call.longitude);
      
      if (lat && lng) {
        // Show the map section if it's not already visible
        document.getElementById('resultSection').style.display = 'flex';
        
        // Center map on this location
        map.setCenter({lat, lng});
        map.setZoom(16);
        
        // Update the Primary Location Details panel
        document.getElementById('formattedAddress').textContent = call.intersection || 'No address';
        document.getElementById('coordinates').textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
        document.getElementById('waypointStatus').textContent = 'From 911 Call: ' + (call.incident_description || call.incident_category || 'Unknown Incident');
        
        // Open Street View at this location
        openStreetView(lat, lng);
        
        // Add a marker for this call
        const callMarker = new google.maps.Marker({
          position: {lat, lng},
          map: map,
          title: call.incident_description || 'Incident',
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: priority === 'HIGH' ? '#e74c3c' : (priority === 'MEDIUM' ? '#f7b500' : '#36b27c'),
            fillOpacity: 0.8,
            strokeWeight: 1,
            strokeColor: '#FFFFFF',
            scale: 10
          }
        });
        
        // Create an info window with call details
        const infoContent = `
          <div class="marker-details">
            <div class="marker-header">${call.incident_category || 'Incident'}</div>
            <div class="marker-content">
              <strong>${call.incident_description || ''}</strong><br>
              <div style="margin: 5px 0">
                <small>Incident #: ${call.incident_number || call.incident_id || 'Unknown'}</small><br>
                <small>${formattedDate} at ${formattedTime}</small><br>
                <small>${call.intersection || 'Location unavailable'}</small><br>
                <small>Coordinates: ${parseFloat(call.latitude).toFixed(6)}, ${parseFloat(call.longitude).toFixed(6)}</small>
              </div>
            </div>
            <div class="marker-footer">
              <button class="marker-action" onclick="addCallAsWaypoint(${lat}, ${lng}, '${(call.incident_description || call.incident_category || 'Incident').replace(/'/g, "\\'")}', '${(call.intersection || 'Unknown location').replace(/'/g, "\\'")}')">
                <i class="bi bi-plus-circle"></i> Add as Waypoint
              </button>
            </div>
          </div>
        `;
        
        const infoWindow = new google.maps.InfoWindow({
          content: infoContent
        });
        
        // Show info window when marker is clicked
        callMarker.addListener('click', function() {
          infoWindow.open(map, callMarker);
        });
        
        // Auto-open the info window
        infoWindow.open(map, callMarker);
      }
    });
    
    callsList.appendChild(callItem);
  });
}

// Helper function to add a 911 call as a waypoint
function addCallAsWaypoint(lat, lng, description, address) {
  // Create waypoint from the 911 call
  const newWaypoint = {
    lat: lat,
    lng: lng,
    address: `${description} at ${address}`,
    name: `Waypoint ${waypoints.length + 1} (911 Call)`,
    altitude: 50
  };
  
  // Add to waypoints array
  waypoints.push(newWaypoint);
  
  // Update the map
  addWaypointToMap(newWaypoint);
  
  // Update the waypoints list UI
  updateWaypointsList();
  
  // Show notification
  alert(`Added 911 call as waypoint: ${description}`);
}

// Filter calls by severity
function filterCallsBySeverity(severity) {
  // If we have no data or selected "all", just show all calls
  if (callsData.length === 0 || severity === 'all') {
    displayCalls(callsData);
    displayCallsOnMap(callsData);
    return;
  }
  
  // Filter the existing data by severity
  const filteredCalls = callsData.filter(call => {
    const category = (call.incident_category || '').toLowerCase();
    
    if (severity === 'high') {
      return category.includes('assault') || 
             category.includes('weapon') || 
             category.includes('robbery') || 
             category.includes('shooting') || 
             category.includes('arson');
    } else if (severity === 'medium') {
      return category.includes('theft') || 
             category.includes('burglary') || 
             category.includes('vehicle') || 
             category.includes('fraud');
    } else if (severity === 'low') {
      return !category.includes('assault') && 
             !category.includes('weapon') && 
             !category.includes('robbery') && 
             !category.includes('shooting') && 
             !category.includes('arson') && 
             !category.includes('theft') && 
             !category.includes('burglary') && 
             !category.includes('vehicle') && 
             !category.includes('fraud');
    }
    
    return true;
  });
  
  // Display the filtered calls in the list
  displayCalls(filteredCalls);
  
  // Update the map with filtered calls
  displayCallsOnMap(filteredCalls);
}

// Search calls based on user input
function searchCalls() {
  const searchInput = document.getElementById('callsSearch');
  const searchTerm = searchInput.value.trim().toLowerCase();
  
  if (!searchTerm || callsData.length === 0) {
    // If no search term or no data, show all calls
    // But respect the current severity filter
    const severityFilter = document.getElementById('callsSeverity').value;
    filterCallsBySeverity(severityFilter);
    return;
  }
  
  // Filter calls based on search term
  const filteredCalls = callsData.filter(call => {
    // Search in multiple fields
    return (call.incident_category && call.incident_category.toLowerCase().includes(searchTerm)) || 
           (call.incident_description && call.incident_description.toLowerCase().includes(searchTerm)) ||
           (call.intersection && call.intersection.toLowerCase().includes(searchTerm)) ||
           (call.incident_number && call.incident_number.toLowerCase().includes(searchTerm));
  });
  
  // Display filtered calls in the list
  displayCalls(filteredCalls);
  
  // Update the map with filtered calls
  displayCallsOnMap(filteredCalls);
}

// Slick tab underline animation
function updateSlickTabUnderline() {
  const tabs = document.querySelectorAll('.slick-tabs .nav-link');
  const underline = document.querySelector('.slick-tab-underline');
  if (!tabs.length || !underline) return;
  let activeIdx = 0;
  tabs.forEach((tab, idx) => {
    if (tab.classList.contains('active')) activeIdx = idx;
  });
  underline.style.left = `${(100 / tabs.length) * activeIdx}%`;
  underline.style.width = `${100 / tabs.length}%`;
}

document.addEventListener('DOMContentLoaded', function() {
  // Animate slick tab underline on tab change
  const tabs = document.querySelectorAll('.slick-tabs .nav-link');
  tabs.forEach(tab => {
    tab.addEventListener('shown.bs.tab', updateSlickTabUnderline);
  });
  updateSlickTabUnderline();
});
async function fetchRecentCalls(limit = 50) {
  try {
    // Clear the calls list and show loading state
    const callsList = document.getElementById('callsList');
    callsList.innerHTML = `
      <div class="text-center p-4 text-muted">
        <div class="spinner-border spinner-border-sm" role="status">
          <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Loading 911 calls...</p>
      </div>
    `;

